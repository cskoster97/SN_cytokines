result_data <- data.frame(
log2FoldChange = sub_results_LFC$log2FoldChange,
baseMean = sub_results_LFC$baseMean,
sig = sub_results_LFC$padj < 0.05  # Creating a binary indicator for significance
)
# Create the plot using ggplot
ggplot(result_data, aes(x = log10(baseMean), y = log2FoldChange, color = sig)) +
geom_point()
DESeq2::plotMA(sub_results, ylim = c(-10, 10))
#inserted chatGPT code as ggplot did not work
#do not think it is necessary
# Extract the relevant information from DESeqResults object
result_data <- data.frame(
log2FoldChange = sub_results_LFC$log2FoldChange,
baseMean = sub_results_LFC$baseMean,
sig = sub_results_LFC$padj < 0.05  # Creating a binary indicator for significance
)
# Create the plot using ggplot
ggplot(result_data, aes(x = log10(baseMean), y = log2FoldChange, color = sig)) +
geom_point()
sub_res_df <- data.frame(sub_results)
sub_res_sig <- subset(sub_res_df, padj < 0.05) %>%
arrange(padj)
write.csv(counts1, file = "./ResultsIL4IL13/Rawcounts_full.csv", row.names = FALSE)
write.csv(sub_res_sig, file = "./ResultsIL4IL13/Rawcounts_full.csv", row.names = FALSE)
write.csv(sub_res_sig, file = "./Results IL4IL13/Rawcounts_full.csv", row.names = FALSE)
getwd()
write.csv(sub_res_sig, file = "/Results IL4IL13/Rawcounts_full.csv", row.names = FALSE)
write.csv(sub_res_sig, file = "./"Results IL4IL13"/Rawcounts_full.csv", row.names = FALSE)
write.csv(sub_res_sig, file = "./Results IL4_IL13/Rawcounts_full.csv", row.names = FALSE)
write.csv(sub_res_sig, file = "./Results IL4_IL13/LogFoldChanges_full.csv", row.names = TRUE)
coculture_sig_norm_counts <- normalized_coculture_counts[rownames(coculture_res_sig),]
normalized_counts <- counts(ddsoverall, normalized = TRUE) #extracted counts normalized by estimateSIzeFactors()
write.csv(normalized_counts, file.path("./Results IL4_Il13/Normalized Counts.csv"))
sig_norm_counts <- normalized_counts[rownames(coculture_res_sig),]
sig_norm_counts <- normalized_counts[rownames(sub_res_sig),]
#display.brewer.all()
heat.colors <- brewer.pal (n = 6, name = "RdYlBu")
pheatmap(sig_norm_counts,
color = colorRampPalette(c("blue", "white", "red"))(50),
cluster_rows = T,
show_rownames = F,
annotation = select(metadata, condition),
scale = "row")
View(sig_norm_counts)
View(metadata_filtered)
View(metadata)
pheatmap(sig_norm_counts,
color = colorRampPalette(c("blue", "white", "red"))(50),
cluster_rows = T,
show_rownames = F,
annotation = select(metadata, Treatment),
scale = "row")
pheatmap(sig_norm_counts,
color = colorRampPalette(c("blue", "white", "red"))(50),
cluster_rows = T,
show_rownames = F,
annotation = select(metadata, Treatment),
scale = "row",
dist.method = "maximum")
pheatmap(sig_norm_counts,
color = colorRampPalette(c("blue", "white", "red"))(50),
cluster_rows = T,
show_rownames = F,
annotation = select(metadata, Treatment),
scale = "row",
dist.method = "manhattan")
pheatmap(sig_norm_counts,
color = colorRampPalette(c("blue", "white", "red"))(50),
cluster_rows = T,
show_rownames = F,
annotation = select(metadata, Treatment),
scale = "row",
dist.method = "canberra")
pheatmap(sig_norm_counts,
color = colorRampPalette(c("blue", "white", "red"))(50),
cluster_rows = T,
show_rownames = F,
annotation = select(metadata, Treatment),
scale = "row",
dist.method = "binary")
pheatmap(sig_norm_counts,
color = colorRampPalette(c("blue", "white", "red"))(50),
cluster_rows = T,
show_rownames = F,
annotation = select(metadata, Treatment),
scale = "row",
dist.method = "minkowski")
pheatmap(sig_norm_counts,
color = colorRampPalette(c("blue", "white", "red"))(50),
cluster_rows = T,
show_rownames = F,
annotation = select(metadata, Treatment),
scale = "row",
dist.method = "euclidean")
sub_significant_genes <- sub_res_sig[(coculture_res_sig$baseMean > 50) & (abs(sub_res_sig$log2FoldChange) > 1),]
sub_significant_genes <- sub_res_sig[(sub_res_sig$baseMean > 50) & (abs(sub_res_sig$log2FoldChange) > 1),]
sub_top_genes <- head(sub_significant_genes, 50)
sub_top50_sig_norm_counts <- merge(normalized_counts, sub_top_genes, by=0)
# Set the row names of the dataframe using the "row.names" column
rownames(sub_top50_sig_norm_counts) <- sub_top50_sig_norm_counts$Row.names
# Remove the "row.names" column
sub_top50_sig_norm_counts$Row.names <- NULL
values_sub_top50_sig_norm_counts <- sub_top50_sig_norm_counts[,1:17]
pheatmap(values_sub_top50_sig_norm_counts,
color = colorRampPalette(c("blue", "white", "red"))(50),
cluster_rows = T,
show_rownames = T,
annotation = select(metadata, condition),
scale = "row")
pheatmap(values_sub_top50_sig_norm_counts,
color = colorRampPalette(c("blue", "white", "red"))(50),
cluster_rows = T,
show_rownames = T,
annotation = select(metadata, Treatment),
scale = "row")
padj_top50_genes <- head(sub_res_sig, 50)
padj_top50_sig_norm_counts <- merge(normalized_counts, padj_top50_genes, by = 0)
values_padj_top50_sig_norm_counts <- padj_top50_sig_norm_counts[,2:17]
# Set the row names of the dataframe using the "row.names" column
rownames(values_padj_top50_sig_norm_counts) <- padj_top50_sig_norm_counts$Row.names
pheatmap(values_padj_top50_sig_norm_counts,
color = colorRampPalette(c("blue", "white", "red"))(50),
cluster_rows = T,
show_rownames = T,
annotation = select(metadata, condition),
scale = "row")
pheatmap(values_padj_top50_sig_norm_counts,
color = colorRampPalette(c("blue", "white", "red"))(50),
cluster_rows = T,
show_rownames = T,
annotation = select(metadata, Treatment),
scale = "row")
# already have ordered file, just extract top20 genes
sub_top20 <- rownames(sub_res_sig [1:20, ])
# extract normalized count values
sub_top20_norm <- normalized_counts[sub_top20, ]
# use melt to modify the format of the data frame
melted_top20 <- data.frame(melt(sub_top20_norm))
# DID NOT WORK: check the column header in the "melted" data frame
# view(melted_EpCAM_top20)
## add column names that make sense
colnames(melted_top20) <- c("gene", "sample_ID", "normalized_counts")
# add metadata to "melted" dataframe
metadata$sample_ID <- rownames(metadata)
melted_top20 <- merge(melted_top20, metadata)
# plot
ggplot(melted_top20) +
geom_point(aes(x = gene, y = normalized_counts, color = sample_ID)) +
scale_y_log10() +
xlab("Genes") +
ylab("Normalized Counts") +
ggtitle("coculture Top 20 Significant DE Genes") +
theme_bw() +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
theme(plot.title=element_text(hjust=0.5)) +
theme(plot.title.position = "plot")
View(sub_res_sig)
EnhancedVolcano(sub_res_Sig,
lab = sub_res_sig$X,
x = 'log2FoldChange',
y = 'padj',
xlim = c(-5, 5), #edit
ylim = c(0, 100), #edit
title = "Effect of coculture on LUVA",
pCutoff = 0.05,
FCcutoff = 1.5, #1
pointSize = 2.0,
labSize = 4.0,
col=c('grey', 'green4', 'blue', 'red3'),
colAlpha = 1)
library("EnhancedVolcano") #install BioC::Manager and then EnhancedVolcano
EnhancedVolcano(sub_res_Sig,
lab = sub_res_sig$X,
x = 'log2FoldChange',
y = 'padj',
xlim = c(-5, 5), #edit
ylim = c(0, 100), #edit
title = "Effect of coculture on LUVA",
pCutoff = 0.05,
FCcutoff = 1.5, #1
pointSize = 2.0,
labSize = 4.0,
col=c('grey', 'green4', 'blue', 'red3'),
colAlpha = 1)
EnhancedVolcano(sub_res_sig,
lab = sub_res_sig$X,
x = 'log2FoldChange',
y = 'padj',
xlim = c(-5, 5), #edit
ylim = c(0, 100), #edit
title = "Effect of coculture on LUVA",
pCutoff = 0.05,
FCcutoff = 1.5, #1
pointSize = 2.0,
labSize = 4.0,
col=c('grey', 'green4', 'blue', 'red3'),
colAlpha = 1)
View(sub_res_sig)
EnhancedVolcano(sub_res_sig,
lab = rownames(sub_res_sig),
x = 'log2FoldChange',
y = 'padj',
xlim = c(-5, 5), #edit
ylim = c(0, 100), #edit
title = "Effect of coculture on LUVA",
pCutoff = 0.05,
FCcutoff = 1.5, #1
pointSize = 2.0,
labSize = 4.0,
col=c('grey', 'green4', 'blue', 'red3'),
colAlpha = 1)
View(sub_results)
View(sub_res_df)
sub_results_lfc$log2FoldChange <- -1 * sub_results_lfc$log2FoldChange
#ALREADY RIGHT FOLDCHANGE SO DONT DO *-1
summary(sub_results_lfc)
head(sub_results_lfc)
sub_results_LFC <- lfcShrink(ddsoverall,
coef = "Treatment_IL4IL13_vs_CTR",
res = sub_results_lfc)
plotMA(sub_results_LFC, ylim = c(-10, 10)) #edit
DESeq2::plotMA(sub_results, ylim = c(-10, 10))
#inserted chatGPT code as ggplot did not work
#do not think it is necessary
# Extract the relevant information from DESeqResults object
result_data <- data.frame(
log2FoldChange = sub_results_LFC$log2FoldChange,
baseMean = sub_results_LFC$baseMean,
sig = sub_results_LFC$padj < 0.05  # Creating a binary indicator for significance
)
# Create the plot using ggplot
ggplot(result_data, aes(x = log10(baseMean), y = log2FoldChange, color = sig)) +
geom_point()
sub_res_df <- data.frame(sub_results)
sub_res_sig <- subset(sub_res_df, padj < 0.05) %>%
arrange(padj)
#Save results table
write.csv(sub_res_sig, file = "./Results IL4_IL13/LogFoldChanges_full2.csv", row.names = TRUE)
sub_results_LFC$log2FoldChange <- -1 * sub_results_lfc$log2FoldChange #switch foldchange sign
plotMA(sub_results_LFC, ylim = c(-10, 10)) #edit
DESeq2::plotMA(sub_results, ylim = c(-10, 10))
#inserted chatGPT code as ggplot did not work
#do not think it is necessary
# Extract the relevant information from DESeqResults object
result_data <- data.frame(
log2FoldChange = sub_results_LFC$log2FoldChange,
baseMean = sub_results_LFC$baseMean,
sig = sub_results_LFC$padj < 0.05  # Creating a binary indicator for significance
)
sub_results_LFC$log2FoldChange <- -1 * sub_results_LFC$log2FoldChange #switch foldchange sign
plotMA(sub_results_LFC, ylim = c(-10, 10)) #edit
DESeq2::plotMA(sub_results, ylim = c(-10, 10))
#inserted chatGPT code as ggplot did not work
#do not think it is necessary
# Extract the relevant information from DESeqResults object
result_data <- data.frame(
log2FoldChange = sub_results_LFC$log2FoldChange,
baseMean = sub_results_LFC$baseMean,
sig = sub_results_LFC$padj < 0.05  # Creating a binary indicator for significance
)
# Create the plot using ggplot
ggplot(result_data, aes(x = log10(baseMean), y = log2FoldChange, color = sig)) +
geom_point()
sub_res_df <- data.frame(sub_results)
sub_res_sig <- subset(sub_res_df, padj < 0.05) %>%
arrange(padj)
#Save results table
write.csv(sub_res_sig, file = "./Results IL4_IL13/LogFoldChanges_full2.csv", row.names = TRUE)
sub_results <- results(ddsoverall, contrast = c("Treatment","CTR", "IL4IL13"),
alpha = 0.5)
#head(sub_results)
sub_results_LFC <- results(ddsoverall,
name = "Treatment_IL4IL13_vs_CTR",
alpha = 0.5)
sub_results_LFC$log2FoldChange <- -1 * sub_results_LFC$log2FoldChange
View(sub_results_LFC)
head(sub_results_LFC)
#head(sub_results)
sub_results_LFC <- results(ddsoverall,
name = "Treatment_IL4IL13_vs_CTR",
alpha = 0.5)
head(sub_results_LFC)
plotMA(sub_results_LFC, ylim = c(-10, 10)) #edit
DESeq2::plotMA(sub_results, ylim = c(-10, 10))
#inserted chatGPT code as ggplot did not work
#do not think it is necessary
# Extract the relevant information from DESeqResults object
result_data <- data.frame(
log2FoldChange = sub_results_LFC$log2FoldChange,
baseMean = sub_results_LFC$baseMean,
sig = sub_results_LFC$padj < 0.05  # Creating a binary indicator for significance
)
# Create the plot using ggplot
ggplot(result_data, aes(x = log10(baseMean), y = log2FoldChange, color = sig)) +
geom_point()
sub_res_df <- data.frame(sub_results)
sub_res_sig <- subset(sub_res_df, padj < 0.05) %>%
arrange(padj)
#Save results table
write.csv(sub_res_sig, file = "./Results IL4_IL13/LogFoldChanges_full2.csv", row.names = TRUE)
#Save results table
write.csv(sub_res_sig, file = "./Results IL4_IL13/LogFoldChanges_full3.csv", row.names = TRUE)
sub_res_df <- data.frame(sub_results_LFC)
sub_res_sig <- subset(sub_res_df, padj < 0.05) %>%
arrange(padj)
#Save results table
write.csv(sub_res_sig, file = "./Results IL4_IL13/LogFoldChanges_full3.csv", row.names = TRUE)
#Save results table
write.csv(sub_res_sig, file = "./Results IL4_IL13/LogFoldChanges_full3.csv", row.names = TRUE)
#Save results table
write.csv(sub_res_sig, file = "./Results IL4_IL13/LogFoldChanges_full.csv", row.names = TRUE)
#plot simple MA plot
plotMA(sub_results_LFC, ylim = c(-10, 10)) #edit
DESeq2::plotMA(sub_results, ylim = c(-10, 10))
# Extract the relevant information from DESeqResults object
result_data <- data.frame(
log2FoldChange = sub_results_LFC$log2FoldChange,
baseMean = sub_results_LFC$baseMean,
sig = sub_results_LFC$padj < 0.05  # Creating a binary indicator for significance
)
# Create the plot using ggplot
ggplot(result_data, aes(x = log10(baseMean), y = log2FoldChange, color = sig)) +
geom_point()
#plot simple MA plot
plotMA(sub_results_LFC, ylim = c(-10, 10)) #edit
DESeq2::plotMA(sub_results, ylim = c(-10, 10))
sub_res_df <- data.frame(sub_results_LFC)
sub_res_sig <- subset(sub_res_df, padj < 0.05) %>%
arrange(padj)
#Save results table
write.csv(sub_res_sig, file = "./Results IL4_IL13/LogFoldChanges_full.csv", row.names = TRUE)
```{r}
EnhancedVolcano(sub_res_sig,
lab = rownames(sub_res_sig),
x = 'log2FoldChange',
y = 'padj',
xlim = c(-5, 5), #edit
ylim = c(0, 100), #edit
title = "Effect of coculture on LUVA",
pCutoff = 0.05,
FCcutoff = 1.5, #1
pointSize = 2.0,
labSize = 4.0,
col=c('grey', 'green4', 'blue', 'red3'),
colAlpha = 1)
EnhancedVolcano(sub_res_sig,
lab = rownames(sub_res_sig),
x = 'log2FoldChange',
y = 'padj',
xlim = c(-5, 5), #edit
ylim = c(0, 100), #edit
title = "Effect of IL4+IL13 on hPSC-dericed sensory neurons",
pCutoff = 0.05,
FCcutoff = 1.5, #1
pointSize = 2.0,
labSize = 4.0,
col=c('grey', 'green4', 'blue', 'red3'),
colAlpha = 1)
sig_norm_counts <- normalized_counts[rownames(sub_res_sig),]
#display.brewer.all()
heat.colors <- brewer.pal (n = 6, name = "RdYlBu")
pheatmap(sig_norm_counts,
color = colorRampPalette(c("blue", "white", "red"))(50),
cluster_rows = T,
show_rownames = F,
annotation = select(metadata, Treatment),
scale = "row",
dist.method = "euclidean")
sub_significant_genes <- sub_res_sig[(sub_res_sig$baseMean > 50) & (abs(sub_res_sig$log2FoldChange) > 1),]
sub_top_genes <- head(sub_significant_genes, 50)
sub_top50_sig_norm_counts <- merge(normalized_counts, sub_top_genes, by=0)
# Set the row names of the dataframe using the "row.names" column
rownames(sub_top50_sig_norm_counts) <- sub_top50_sig_norm_counts$Row.names
# Remove the "row.names" column
sub_top50_sig_norm_counts$Row.names <- NULL
values_sub_top50_sig_norm_counts <- sub_top50_sig_norm_counts[,1:17]
pheatmap(values_sub_top50_sig_norm_counts,
color = colorRampPalette(c("blue", "white", "red"))(50),
cluster_rows = T,
show_rownames = T,
annotation = select(metadata, Treatment),
scale = "row")
padj_top50_genes <- head(sub_res_sig, 50)
padj_top50_sig_norm_counts <- merge(normalized_counts, padj_top50_genes, by = 0)
values_padj_top50_sig_norm_counts <- padj_top50_sig_norm_counts[,2:17]
# Set the row names of the dataframe using the "row.names" column
rownames(values_padj_top50_sig_norm_counts) <- padj_top50_sig_norm_counts$Row.names
pheatmap(values_padj_top50_sig_norm_counts,
color = colorRampPalette(c("blue", "white", "red"))(50),
cluster_rows = T,
show_rownames = T,
annotation = select(metadata, Treatment),
scale = "row")
padj_top50_genes <- head(sub_res_sig, 50)
padj_top50_sig_norm_counts <- merge(normalized_counts, padj_top50_genes, by = 0)
values_padj_top50_sig_norm_counts <- padj_top50_sig_norm_counts[,2:17]
# Set the row names of the dataframe using the "row.names" column
rownames(values_padj_top50_sig_norm_counts) <- padj_top50_sig_norm_counts$Row.names
pheatmap(values_padj_top50_sig_norm_counts,
color = colorRampPalette(c("blue", "white", "red"))(50),
cluster_rows = T,
show_rownames = T,
annotation = select(metadata, Treatment),
scale = "row")
# already have ordered file, just extract top20 genes
sub_top20 <- rownames(sub_res_sig [1:20, ])
# extract normalized count values
sub_top20_norm <- normalized_counts[sub_top20, ]
# use melt to modify the format of the data frame
melted_top20 <- data.frame(melt(sub_top20_norm))
# DID NOT WORK: check the column header in the "melted" data frame
# view(melted_EpCAM_top20)
## add column names that make sense
colnames(melted_top20) <- c("gene", "sample_ID", "normalized_counts")
# add metadata to "melted" dataframe
metadata$sample_ID <- rownames(metadata)
melted_top20 <- merge(melted_top20, metadata)
# plot
ggplot(melted_top20) +
geom_point(aes(x = gene, y = normalized_counts, color = sample_ID)) +
scale_y_log10() +
xlab("Genes") +
ylab("Normalized Counts") +
ggtitle("coculture Top 20 Significant DE Genes") +
theme_bw() +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
theme(plot.title=element_text(hjust=0.5)) +
theme(plot.title.position = "plot")
pheatmap(sig_norm_counts,
color = colorRampPalette(c("blue", "white", "red"))(50),
cluster_rows = T,
show_rownames = F,
annotation = select(metadata, Treatment),
scale = "row",
dist.method = "euclidean")
pheatmap(sub_res_sig,
color = colorRampPalette(c("blue", "white", "red"))(50),
cluster_rows = T,
show_rownames = F,
annotation = select(metadata, Treatment),
scale = "row",
dist.method = "euclidean")
# Select top genes based on adjusted p-values
# sub_res_sig is the DESeq2 result table (e.g., results(dds))
top_genes <- head(order(sub_res_sig$padj), 50)
# Extract normalized counts for the top significant genes
top_norm_counts <- normalized_counts[top_genes, ]
# Optionally, log-transform the counts (adding 1 to avoid log of 0)
log_transformed_counts <- log2(top_norm_counts + 1)
# Create a heatmap using pheatmap
library(pheatmap)
# Create a heatmap using pheatmap
pheatmap(log_transformed_counts,
color = colorRampPalette(c("blue", "white", "red"))(50),
scale = "row",  # Scale by row to see relative expression
show_rownames = TRUE,
cluster_rows = TRUE,
annotation = select(metadata, condition))  # Add condition metadata
# Create a heatmap using pheatmap
pheatmap(log_transformed_counts,
color = colorRampPalette(c("blue", "white", "red"))(50),
scale = "row",  # Scale by row to see relative expression
show_rownames = TRUE,
cluster_rows = TRUE,
annotation = select(metadata, Treatment))  # Add condition metadata
View(sub_res_sig)
View(top_norm_counts)
print(top_genes)
# Select top genes based on adjusted p-values
# sub_res_sig is the DESeq2 result table (e.g., results(dds))
sub_res_sig_order <- head(order(sub_res_sig$padj), 50)
top_genes <- rownames(sub_res_sig)[1:50]  # Get the gene names or rownames
View(sub_res_sig)
# Select top genes based on adjusted p-values
# sub_res_sig is the DESeq2 result table (e.g., results(dds))
sub_res_sig_order <- (order(sub_res_sig$padj))
sub_res_sig_order <- sub_res_sig[order(sub_res_sig$padj), ] # Sort sub_res_sig by the padj column and retain all information
View(sub_res_sig_order)
# Select top genes based on adjusted p-values
top_genes <- rownames(sub_res_sig)[1:50]  # Get the gene names or rownames
# Extract normalized counts for the top significant genes
top_norm_counts <- normalized_counts[top_genes, ]
# Optionally, log-transform the counts (adding 1 to avoid log of 0)
log_transformed_counts <- log2(top_norm_counts + 1)
# Create a heatmap using pheatmap
pheatmap(log_transformed_counts,
color = colorRampPalette(c("blue", "white", "red"))(50),
scale = "row",  # Scale by row to see relative expression
show_rownames = TRUE,
cluster_rows = TRUE,
annotation = select(metadata, Treatment))  # Add condition metadata
# Perform PCA
pca <- prcomp(t(vsd_cor), scale. = TRUE)
# Calculate the proportion of variance explained by each component
explained_variance <- pca$sdev^2 / sum(pca$sdev^2)
# Create a data frame to store the results
pca_variance_df <- data.frame(PC = 1:length(explained_variance),
Variance = explained_variance)
# ggplot2 scree plot
ggplot(pca_variance_df, aes(x = PC, y = Variance)) +
geom_line() +
geom_point() +
theme_minimal() +
labs(x = "Principal Components", y = "Proportion of Variance Explained",
title = "Scree Plot") +
scale_x_continuous(breaks = pca_variance_df$PC)
# simple PCA
plotPCA(vsd_overall, intgroup = c("Experiment", "Treatment"))
plotPCA(vsd_overall, intgroup = "Treatment")
plotPCA(vsd_overall, intgroup = "Experiment")
plotPCA(vsd_overall, intgroup = c("Experiment", "Treatment"))
