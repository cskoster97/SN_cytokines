---
title: "Rscript Data Analysis coculture_EpCAM_fibroblasts"
output: html_document
date: "2023-03-23"
editor_options: 
  chunk_output_type: console
---

If necessary, download the required libraries
```{r}
if (!require("BiocManager", quietly = TRUE))
  install.packages("BiocManager")
BiocManager::install(version = "3.16")

BiocManager::install("DESeq2")
BiocManager::install("tidyverse")
BiocManager::install("ggrepel")
install.packages("ggplot2")
install.packages("ggfortify")
BiocManager::install("RColorBrewer")
BiocManager::install("pheatmap")
install.packages("reshape")
BiocManager::install("PCAtools")
#BiocManager::install("apeglm")
#BiocManager::install("annotables")
install.packages("openxlsx")
```

Load required libraries
```{r}
library("DESeq2")
library("edgeR")
library("tidyverse")
library("ggrepel")
library("ggplot2")
library("ggfortify")
library("RColorBrewer")
library("pheatmap")
library("reshape")
library(openxlsx)
#library("annotables") #genesymbols aan ID matchen
```

Background info and help with DESeq2
```{r}
#browseVignettes(package = "DESeq2")
```

Load metadata and counts files
```{r}
# load the metadata and rowcount.csv file
setwd("G:/My Drive/RNAseq/Carli_SN+Cytokines/Analysis Carli")
#counts <- read.csv(file.path("Rawcounts.csv"))

metadata <- read.csv("Metadata.csv", row.names=1)
counts <- read.csv("analyse/Rawcounts.csv", row.names=1)

#Make gene names the rownames instead of the numbering                   
#rownames(counts) <- counts$Gene
#counts<-counts[,-1]

#Make sample names the rownames instead of the numbering  
#rownames(metadata1) <- metadata1$X
#metadata<-metadata1[,-1]


# check if order of samples is the same in metadata and count table
rownames(metadata)
colnames(counts)
all(rownames(metadata) == colnames(counts))
```

Create DESEq2 object
```{r}
# remember that DESeq2 will output results for the last term in the formula 
ddsoverall <- DESeqDataSetFromMatrix(countData = counts, 
                                  colData = metadata, 
                                  design = ~ Experiment + Treatment + Experiment:Treatment)
ddsoverall$Treatment <- factor(ddsoverall$Treatment, levels = c("CTR", "TGF", "IL6", "IL4IL13"))

#ddsoverall<- DESeq(ddsoverall)

# Now you can access results with the desired contrast name
#resultsNames(ddsoverall)
```

Prefiltering
```{r}
keep <- rowSums(counts(ddsoverall)) >= 10
ddsoverall <- ddsoverall[keep,]
```

DEA + fit raw counts to negative binomial model, count normalization 
```{r}
ddsoverall <- estimateSizeFactors(ddsoverall)
ddsoverall <- DESeq(ddsoverall)

resultsNames(ddsoverall)

# Run contrasts
resTGF <- results(ddsoverall, contrast = c("Treatment", "TGF", "CTR"))
resIL6 <- results(ddsoverall, contrast = c("Treatment", "IL6", "CTR"))
resIL4IL13 <- results(ddsoverall, contrast = c("Treatment", "IL4IL13", "CTR"))

# Generate data table of epithelial data
resoverall <- results(ddsoverall)

# write to csv
write.csv(resoverall, "Overall comparison.csv")
write.csv(resTGF, "TGF comparison.csv")
write.csv(resIL6, "IL6 comparison.csv")
write.csv(resIL4IL13, "IL4IL13 comparison.csv")

plotDispEsts(ddsoverall)
resultsNames(ddsoverall)
colData(ddsoverall)
```

Count normalization #waarom normaliseer je 2x? DESEQ2 doet dit al? - kan je niet de genormaliseerde data van Deseq2 niet exporteren?
```{r}
normalized_counts <- counts(ddsoverall, normalized = TRUE)
log2_normalized_counts <- log2(normalized_counts + 1)  # Adding 1 to avoid log(0)
write.xlsx(as.data.frame(log2_normalized_counts), "log2normalized_counts.xlsx", rowNames = TRUE)

```

Log transformation 
```{r}
vsd_overall <- vst(ddsoverall, blind = TRUE)
vsd_TGF <- vst(resTGF, blind = TRUE)
```

Heatmap of sample correlation values
```{r}
vsd_mat <- assay(vsd_overall)
vsd_cor <- cor(vsd_mat)
vsd_cor

pheatmap(vsd_cor, annotation = select(metadata, Treatment))
```

PCA (different options) directly on the vst values instead 
```{r}
# simple PCA 
plotPCA(vsd_overall, intgroup = c("Experiment", "Treatment"))
plotPCA(vsd_overall, intgroup = "Treatment")
plotPCA(vsd_overall, intgroup = "Experiment")


plotPCA(vsd_overall, intgroup = c("Experiment", "Treatment"))
plotPCA(vsd_overall, intgroup = "Treatment")

# labeled PCA (can change text with repel for white box)
labeled_PCA <- plotPCA(vsd_overall, intgroup = c("Experiment", "Treatment"))
labeled_PCA + geom_text_repel(aes_string(x = "PC1", y = "PC2", label = "name"), color = "black", size = 2)

# PCA with different shapes 
new_PCA <- plotPCA(vsd_overall, intgroup = c("Experiment", "Treatment"), returnData = TRUE)
percentVar <- round(100 * attr(new_PCA, "percentVar"))

ggplot(new_PCA, aes(PC1, PC2, color=cell_type, shape=condition)) +
  geom_point(size=3) +
  xlab(paste0("PC1: ", percentVar[1], "% variance")) + 
  ylab(paste0("PC2: ", percentVar[2], "% variance")) + 
  coord_fixed()
```

Extract results 
```{r}
coculture_results <- results(ddsoverall, contrast = c("condition", "co", "mono"),
                       name = "condition_mono_vs_co",
                       alpha = 0.5)
head(coculture_results)
coculture_results_lfc <- results(ddsoverall,
                       name = "condition_mono_vs_co",
                       alpha = 0.5)
coculture_results_lfc$log2FoldChange <- -1 * coculture_results_lfc$log2FoldChange
summary(coculture_results_lfc)
head(coculture_results_lfc)
```

LFC, MA plot 
```{r}
coculture_results_LFC <- lfcShrink(ddsoverall,
                             coef = "condition_mono_vs_co", 
                             res = coculture_results_lfc)

plotMA(coculture_results_LFC, ylim = c(-10, 20)) #edit
DESeq2::plotMA(coculture_results, ylim = c(-10, 10))

ggplot(coculture_results_LFC, aes(x = log10(baseMean), y = log2FoldChange, color = sig)) + 
  geom_point()

#inserted chatGPT code as ggplot did not work
#do not think it is necessary
# Extract the relevant information from DESeqResults object
result_data <- data.frame(
  log2FoldChange = coculture_results_LFC$log2FoldChange,
  baseMean = coculture_results_LFC$baseMean,
  sig = coculture_results_LFC$padj < 0.05  # Creating a binary indicator for significance
)

# Create the plot using ggplot
ggplot(result_data, aes(x = log10(baseMean), y = log2FoldChange, color = sig)) + 
  geom_point()

```

Obtain significant results table and order by padj
```{r}
coculture_res_df <- data.frame(coculture_results)
coculture_res_sig <- subset(coculture_res_df, padj < 0.05) %>%
  arrange(padj)
```

#Save results table -> copy first row -> ensembl_gene_converter -> import
```{r}
write.csv(counts1, file = "./analyse/Rawcounts_full.csv", row.names = FALSE)
#coculture_res_ID <- read.csv("coculture_res_sig.csv", row.names = 1) #what?
```

Heatmap of all genes 
```{r}
coculture_sig_norm_counts <- normalized_coculture_counts[rownames(coculture_res_sig),]
#display.brewer.all()
heat.colors <- brewer.pal (n = 6, name = "RdYlBu")
#display.brewer.all()

pheatmap(coculture_sig_norm_counts, 
         color = colorRampPalette(c("blue", "white", "red"))(50), 
         cluster_rows = T,
         show_rownames = F, 
         annotation = select(metadata, condition),
         scale = "row") 
```

Heatmap of top50 genes filtered #1
```{r}
coculture_significant_genes <- coculture_res_sig[(coculture_res_sig$baseMean > 50) & (abs(coculture_res_sig$log2FoldChange) > 1),]
coculture_top_genes <- head(coculture_significant_genes, 50)
coculture_top50_sig_norm_counts <- merge(normalized_coculture_counts, coculture_top_genes, by=0)

# Set the row names of the dataframe using the "row.names" column
rownames(coculture_top50_sig_norm_counts) <- coculture_top50_sig_norm_counts$Row.names
# Remove the "row.names" column
coculture_top50_sig_norm_counts$Row.names <- NULL

values_coculture_top50_sig_norm_counts <- coculture_top50_sig_norm_counts[,1:17]

#coculture_top_genes_ID <- head(coculture_res_ID, 50)
#row.names(values_coculture_top50_sig_norm_counts) <- row.names(coculture_top_genes_ID)

#heatmap <- pheatmap(log2(values_coculture_top50_sig_norm_counts +1), scale = 'row', show_rownames = T, treeheight_row  = 0)
#png("top_genes_heatmap", res = 250, width = 1000, height = 2000)

pheatmap(values_coculture_top50_sig_norm_counts, 
         color = colorRampPalette(c("blue", "white", "red"))(50), 
         cluster_rows = T,
         show_rownames = T, 
         annotation = select(metadata, condition),
         scale = "row") 
```

Heatmap of top50 genes (padj)
```{r}
padj_top50_genes <- head(coculture_res_sig, 50)
padj_top50_sig_norm_counts <- merge(normalized_coculture_counts, padj_top50_genes, by = 0)
values_padj_top50_sig_norm_counts <- padj_top50_sig_norm_counts[,2:17]

# Set the row names of the dataframe using the "row.names" column
rownames(values_padj_top50_sig_norm_counts) <- padj_top50_sig_norm_counts$Row.names

#padj_top50_genes_ID <- head(coculture_res_ID, 50)
#row.names(values_padj_top50_sig_norm_counts) <- row.names(padj_top50_genes_ID)

pheatmap(values_padj_top50_sig_norm_counts, 
         color = colorRampPalette(c("blue", "white", "red"))(50), 
         cluster_rows = T,
         show_rownames = T, 
         annotation = select(metadata, condition),
         scale = "row") 
```

Plot expression of the top20 genes
```{r}
# already have ordered file, just extract top20 genes
coculture_top20 <- rownames(coculture_res_sig [1:20, ])
# extract normalized count values
coculture_top20_norm <- normalized_coculture_counts[coculture_top20, ]
# use melt to modify the format of the data frame
melted_top20 <- data.frame(melt(coculture_top20_norm))
# DID NOT WORK: check the column header in the "melted" data frame
# view(melted_EpCAM_top20)
## add column names that make sense
colnames(melted_top20) <- c("gene", "sample_ID", "normalized_counts")
# add metadata to "melted" dataframe
metadata$sample_ID <- rownames(metadata)
melted_top20 <- merge(melted_top20, metadata)
# plot
ggplot(melted_top20) +
  geom_point(aes(x = gene, y = normalized_counts, color = sample_ID)) +
  scale_y_log10() +
  xlab("Genes") +
  ylab("Normalized Counts") +
  ggtitle("coculture Top 20 Significant DE Genes") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  theme(plot.title=element_text(hjust=0.5)) +
  theme(plot.title.position = "plot")
```

